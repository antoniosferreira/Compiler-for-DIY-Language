%{
#include <stdio.h>
#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include "node.h"
#include "tabid.h"
#include "postfix.h"

extern FILE *outfp;

//Auxiliary variables
int fargs = 0;


%}

%term BLOCO='{'
%term CLOSE='}'
%term ARGS=','
%term END=';'
%term ALLOC='#'
%term FACT='!'
%term ADD='+'
%term SUB='-'
%term MUL='*'
%term DIV='/'
%term MOD='%'
%term LT='<'
%term GT='>'
%term EQ='='
%term AND='&'
%term OR='|'
%term STAR='('
%term EN=')'
%include "y.tab.h"

%%

list    : NIL
list    : VOID                 0   {}
list    : END(list, base)      0   {}
list    : base                 0   {}

base    : expr                    0  {fprintf(outfp, pfTRASH, 4);}

expr    : lv                      0  {}
expr    : ptr_aux                 0  {}
expr    : PTR(ptr_aux)            0  {}
expr    : ATR(dexpr, lv)          0  {fprintf(outfp, pfSTORE);}
expr    : INT                     0  {fprintf(outfp, pfIMM, p->value.i);}
expr    : STR                     0  {}
expr    : REAL                    0  {}
expr    : UMINUS(expr)            0  {}
expr    : NOT(expr)               0  {}
expr    : REF(expr)               0  {}
expr    : FACT(expr)              0  {}
expr    : INCR(lv)                0  {}
expr    : DECR(lv)                0  {}
expr    : POSINC(lv)              0  {}
expr    : POSDEC(lv)              0  {}
expr    : ADD(expr, expr)         0  {fprintf(outfp, pfADD);}
expr    : SUB(expr, expr)         0  {}
expr    : MUL(expr, expr)         0  {}
expr    : DIV(expr, expr)         0  {}
expr    : MOD(expr, expr)         0  {fprintf(outfp, pfMOD);}
expr    : LT(expr, expr)          0  {fprintf(outfp, pfLT);}
expr    : GT(expr, expr)          0  {fprintf(outfp, pfGT);}
expr    : GE(expr, expr)          0  {fprintf(outfp, pfGE);}
expr    : LE(expr, expr)          0  {fprintf(outfp, pfLE);}
expr    : NE(expr, expr)          0  {fprintf(outfp, pfNE);}
expr    : EQ(expr, expr)          0  {fprintf(outfp, pfEQ);}
expr    : AND(expr, expr)         0  {fprintf(outfp, pfAND);}
expr    : OR(expr, expr)          0  {fprintf(outfp, pfOR);}
expr    : CALL(ID, fargs)         0  {fprintf(outfp, pfCALL pfTRASH pfPUSH, LEFT_CHILD(p)->value.s, fargs); fargs =0;}

fargs   : ARGS(fargs, fargs)         0 {}
fargs   : ARGS(NIL, expr)            0 {fargs = fargs + 4; }

ptr_aux : PTR(lv)                 0  {}

lv  : LOCAL    0 {/*LOCAL*/ fprintf(outfp, pfLOCAL, p->value.i);}
lv  : ID       0 {/*GLOBAL*/fprintf(outfp, pfADDR, p->value.s);}

dexpr: expr    0 { fprintf(outfp, pfDUP); }

%%
#include "y.tab.h"
extern void yyerror(const char*);
extern char **yynames;
extern int trace;


void pfFunction(char* name, int type, Node* body, int enter) {

    // No body
    if (body == 0) {
        fprintf(outfp, pfEXTRN, name);
        return;
    }

    // Function has body
    if (strcmp(name, "entry") == 0)
        fprintf(outfp, pfTEXT pfALIGN pfGLOBL pfLABEL pfENTER, "entry", pfFUNC, "entry", enter);
    else
        fprintf(outfp, pfTEXT pfALIGN pfGLOBL pfLABEL pfENTER, name, pfFUNC, name, enter);

    // Goes through function body
    printNode(body, stdout, yynames);
    yyselect(LEFT_CHILD(body)); // only needs to postfix instrs

    // Void (no return)
    if (type == VOID)
        fprintf(outfp, pfLEAVE pfRET);
    else
        fprintf(outfp, pfLOCAL pfLOAD pfPOP pfLEAVE pfRET, -4);

}

void pfVariable(char *name, Node* type, Node* value) {

    // not initialized
    if (type->value.i == 0)
        fprintf(outfp, pfBSS pfALIGN pfLABEL pfBYTE pfTEXT, name, 4);
    // constant
    else if (type->value.i > 5)
        fprintf(outfp, pfRODATA pfALIGN);

    // initialized
    else
        fprintf(outfp, pfDATA pfALIGN);

    fprintf(outfp, pfLABEL, name);

    if (type->value.i == INT)
        fprintf(outfp, pfIMM, value->value.i);
    else if (type->value.i == STR)
        fprintf(outfp, pfSTR, value->value.s);
}